//Tetris
//Joseph Dykstra


//              PREPROCESSOR
#include "+Button+-.nxc"
#include "+Highscore.nxc"
#include "+RotatedNumbers.nxc"
//Dimensions / Graphics
#define blksz   4
#define width   10
#define height  25
#define TX      35
#define SX      94
#define SY      61
#define msgX    0
#define msgY    56
#define defaultmode     1
#define previewPieces   3
//Timing (all *10)
#define waitGravity     5
#define waitSlowMove    3
#define waitFastMove    0
#define waitRotateAgain 3
#define waitHardDrop    3
#define waitLock        5
#define fastRepeat      5
//Buttons
#define BtnMoveL  BTNCENTER
#define BtnMoveR  BTNEXIT
#define BtnRotate BTNRIGHT
#define BtnDrop   BTNLEFT
//Move()
#define dwn 0
#define lft 1
#define rht 2
#define sty 3
//Drop
#define dropHard  1 //Normal
#define dropSoft  2 //Normal
#define dropWHard 3 //Wait
#define dropWSoft 4 //Wait
//Tetriminos
#define Itet 0
#define Jtet 1
#define Ltet 2
#define Otet 3
#define Stet 4
#define Ttet 5
#define Ztet 6
#define prob 7


//                 GLOBAL CONSTANTS
const bool  allowDbg[5]={0,0,1,0,0};
const short tet[8][28]=
  {
// I
  {0,1,2,3,
   1,1,1,1}
  {2,2,2,2,
   0,1,2,3}
  {0,1,2,3,
   2,2,2,2}
  {1,1,1,1,
   0,1,2,3}
// J
  {0,1,2,0,
   1,1,1,0}
  {1,1,1,2,
   0,1,2,0}
  {0,1,2,2,
   1,1,1,2}
  {1,1,1,0,
   0,1,2,2}
// L
  {0,1,2,2,
   1,1,1,0}
  {1,1,1,2,
   0,1,2,2}
  {0,0,1,2,
   2,1,1,1}
  {0,1,1,1,
   0,0,1,2}
// O
  {1,1,2,2,
   0,1,0,1}
  {1,1,2,2,
   0,1,0,1}
  {1,1,2,2,
   0,1,0,1}
  {1,1,2,2,
   0,1,0,1}
// S
  {2,1,1,0,
   0,0,1,1}
  {1,1,2,2,
   0,1,1,2}
  {2,1,1,0,
   1,1,2,2}
  {0,0,1,1,
   0,1,1,2}
//T
  {0,1,1,2,
   1,1,0,1}
  {1,1,2,1,
   0,1,1,2}
  {0,1,1,2,
   1,1,2,1}
  {1,1,0,1,
   0,1,1,2}
// Z
  {0,1,1,2,
   0,0,1,1}
  {1,1,2,2,
   2,1,1,0}
  {0,1,1,2,
   1,1,2,2}
  {0,0,1,1,
   2,1,1,0}
  };


//                 GLOBAL VARIABLES
string msg         ="";
string disp        ="";
string accesshigh  ="";
float speedup      = 0;
int viewDbg        =-1;
int score          = 0;
int gametype       = 0;
int gamespeed      = 0;
int delaytime      = 0;
int lockDelay      = 0;
int prevRht        = 0;
int prevLft        = 0;
int prevDrp        = 0;
int prevRot        = 0;
int currentPiece   = 0;
int currentRotate  = 0;
int prevWaited     = 0;
int tetLR          = 0;
int tetUD          = 0;
int drop           = 0;
bool alive         = 0;
bool prevQuadClear = 0;
bool highMade      = 0;


bool area[width][height+2];
int chnc[8];
int nextPiece[previewPieces];


//                 SUBROUTINES
void selectGame(bool INfastmode)
  {
  prevQuadClear=false;
  prevRht=0;
  prevLft=0;
  score=0;
  disp="";
  accesshigh="Tet";
  if (INfastmode) //debugging
    {
    gamespeed=0;
    gametype=2;
    }
  else
    {
    while (ButtonPressed(BTNRIGHT)==false)
      {
      gamespeed=senseButton(gamespeed,false,1,2,false);
      ClearScreen();
      TextOut(TX,LCD_LINE1,"TETRIS", 0);
      TextOut(2, LCD_LINE2,"Speed:", 0);
      TextOut(2, LCD_LINE3,"Slow",   0);
      TextOut(2, LCD_LINE4,"Medium", 0);
      TextOut(2, LCD_LINE5,"Fast",   0);
      TextOut(88,LCD_LINE8,"OK",     0);
      RectOut(0,40-(gamespeed*8),49,8,0);
      Wait(50);
      }
    TextOut(TX,LCD_LINE1,"TETRIS",  0);
    until (ButtonPressed(BTNRIGHT)==false) {}
    while (ButtonPressed(BTNRIGHT)==false)
      {
      gametype=senseButton(gametype,false,1,4,false);
      ClearScreen();
      TextOut(TX,LCD_LINE1,"TETRIS",   0);
      TextOut(2, LCD_LINE2,"Type:",    0);
      TextOut(2, LCD_LINE3,"Giveaway", 0);
      TextOut(2, LCD_LINE4,"Simple",   0);
      TextOut(2, LCD_LINE5,"Normal",   0);
      TextOut(2, LCD_LINE6,"Hard",     0);
      TextOut(2, LCD_LINE7,"Death",    0);
      TextOut(88,LCD_LINE8,"OK", 0);
      RectOut(0,40-(gametype*8),49,8,0);
      Wait(50);
      }
    }
  TextOut(TX,LCD_LINE1,"TETRIS",  0);
  until (ButtonPressed(BTNRIGHT)==false) {}
  //
  if      (gamespeed==0)
    {
    accesshigh=StrCat(accesshigh,"Slow");
    speedup=0.975;
    delaytime=800;
    }
  else if (gamespeed==1)
    {
    accesshigh=StrCat(accesshigh,"Med");
    speedup=0.9375;
    delaytime=600;
    }
  else if (gamespeed==2)
    {
    accesshigh=StrCat(accesshigh,"Fast");
    speedup=0.9;
    delaytime=400;
    }
  if      (gametype==0)
    {
    accesshigh=StrCat(accesshigh,"Give.dat");
    chnc[Itet]=2;
    chnc[Jtet]=1;
    chnc[Ltet]=1;
    chnc[Otet]=2;
    chnc[Stet]=0;
    chnc[Ttet]=1;
    chnc[Ztet]=0;
    chnc[prob]=7;
    }
  else if (gametype==1)
    {
    accesshigh=StrCat(accesshigh,"Simp.dat");
    chnc[Itet]=3;
    chnc[Jtet]=1;
    chnc[Ltet]=1;
    chnc[Otet]=3;
    chnc[Stet]=1;
    chnc[Ttet]=2;
    chnc[Ztet]=1;
    chnc[prob]=12;
    }
  else if (gametype==2)
    {
    accesshigh=StrCat(accesshigh,"Norm.dat");
    chnc[Itet]=1;
    chnc[Jtet]=1;
    chnc[Ltet]=1;
    chnc[Otet]=1;
    chnc[Stet]=1;
    chnc[Ttet]=1;
    chnc[Ztet]=1;
    chnc[prob]=7;
    }
  else if (gametype==3)
    {
    accesshigh=StrCat(accesshigh,"Hard.dat");
    chnc[Itet]=2;
    chnc[Jtet]=3;
    chnc[Ltet]=3;
    chnc[Otet]=2;
    chnc[Stet]=4;
    chnc[Ttet]=3;
    chnc[Ztet]=4;
    chnc[prob]=21;
    }
  else if (gametype==4)
    {
    accesshigh=StrCat(accesshigh,"Death.dat");
    chnc[Itet]=1;
    chnc[Jtet]=3;
    chnc[Ltet]=3;
    chnc[Otet]=2;
    chnc[Stet]=4;
    chnc[Ttet]=2;
    chnc[Ztet]=4;
    chnc[prob]=19;
    }
  else if (gametype==5) //DEBUG ONLY
    {
    accesshigh=StrCat(accesshigh,"Death.dat");
    chnc[Itet]=0;
    chnc[Jtet]=1;
    chnc[Ltet]=0;
    chnc[Otet]=2;
    chnc[Stet]=0;
    chnc[Ttet]=0;
    chnc[Ztet]=1;
    chnc[prob]=4;
    }
  ClearScreen();
  }

//  ______   ______   ______   ______   ______   ______   ______   ______
//  |__  _|  |__  _|  |__  _|  |__  _|  |__  _|  |__  _|  |__  _|  |__  _|
//  _  ||    _  ||    _  ||    _  ||    _  ||    _  ||    _  ||    _  ||
//  \\_//    \\_//    \\_//    \\_//    \\_//    \\_//    \\_//    \\_//
//   \_/      \_/      \_/      \_/      \_/      \_/      \_/      \_/

bool move(int INdir)
  {
  int canMove=0;
  int addLR=0;
  int addUD=0;
  int tempLR;
  int tempUD;
  if      (INdir==dwn) addUD=-1;
  else if (INdir==lft) addLR= 1;
  else if (INdir==rht) addLR=-1;
  for (int i=0; i<4; i++)
    {
    tempLR=tet[currentPiece+currentRotate][i  ]+tetLR+addLR;
    tempUD=tet[currentPiece+currentRotate][i+4]+tetUD+addUD;
    if ((tempLR>=0)&&(tempUD>=0)&&(tempLR<width)) //&&(tempUD<height)
      {canMove+=(area[tempLR][tempUD]);} //PointOut(tempUD*blksz+1,tempLR*blksz+1,0);}
    else canMove++;
    if (tetUD<1&&INdir==dwn) {canMove=3;}// PlayTone(3000,500);}
    }
  //NumOut(0,16,canMove,0);
  //Wait(500);
  return (canMove==0); //canMove in:  0123
  }                    //canMove out: 1000


int rotate(bool INdwn)
  {
  int canRotate=0, addRot=0, tempLR, tempUD, addUD, addLR;
  bool stayInLoop=true;
  if (currentRotate>=3) addRot=-3;
  else                  addRot=1;
  for (int i=0; (i<3 && stayInLoop); addUD++)
    {
    //TextOut(25,48,"rotate()",0);
    if (i==0) addUD= 0;  //1st  Level
    if (i==1) addUD=-1;  //2nd  Down
    if (i==2) addUD= 1;  //3rd  Up
    addLR=0;
    for (int j=0; (j<3 && stayInLoop); j++)
      {
      if (j==0) addLR= 0;  //1st  Center
      if (j==1) addLR=-1;  //2nd  Right
      if (j==2) addLR= 1;  //3rd  Left
      canRotate=0;
      for (int i=0; i<4; i++)
        {
        tempLR=tet[currentPiece+currentRotate+addRot][i  ]+tetLR+addLR;
        tempUD=tet[currentPiece+currentRotate+addRot][i+4]+tetUD+addUD;
        if ((tempLR>=0)&&(tempUD>=0)&&(tempLR<width)&&(tempUD<height)&&(tetUD>0))
          {canRotate+=(area[tempLR][tempUD]);}
        else canRotate++;
        }
      stayInLoop=(canRotate!=0);
      }
    }
  if (!stayInLoop)
    {
    if (INdwn)
      {canRotate=addUD;}
    else
      {canRotate=addLR;}
    }
  else {canRotate=-5;}
  return canRotate;
  }

                                       //in is updown leftright
void displayTetromino(int INtet,int INrot, int INlr, int INud, int INdrawMode)
  {
  int tempLR,tempUD;
  for (int i=0; i<4; i++)
    {
    //tempLR=56-(INlr+(tet[INtet+INrot][i  ])*blksz); //inverted
    tempLR=   (INlr+(tet[INtet+INrot][i  ])*blksz);
    tempUD=   (INud+(tet[INtet+INrot][i+4])*blksz);

    //Wait(500);
    if      (INdrawMode==0) RectOut(tempUD,tempLR,blksz,blksz,32);
    else if (INdrawMode==1) RectOut(tempUD,tempLR,blksz,blksz,0);
    else if (INdrawMode==2) CircleOut(tempUD+blksz/2,tempLR+blksz/2,blksz/2-1,0);//change so it looks different
    }
  }

// BEGIN  _ _        __
//         |     /  /  \
//         |    /   |  |
//        _|_  /    \__/
//       ================

bool inputOutput(bool INallowInput, bool INallowOutput, bool INallowDraw, int INwaited)
  {
  bool temppiecemoving=true; //return this
  bool refresh=false; //refresh the screen
  TextOut(25,48,"  INPUT ",0);
//INPUT
  if (INallowInput)
    {
    if (ButtonPressed(BtnDrop))
      {
      if (prevDrp>waitHardDrop) {lockDelay=0; drop=dropWSoft;} //Instant Hard Drop  //////////////////////////////
      else               {lockDelay=waitLock; drop=dropWHard;} //Wait for Soft Drop //////////////////////////////
      prevDrp++;
      }
    else
      {
      if (drop==dropWHard || drop==dropWSoft) {drop-=2; refresh=true;}
      }
    if (ButtonPressed(BtnRotate))
      {
      lockDelay=0;
      if (prevRot==0)
        {
        int tempRotStatDwn=rotate(dwn);
        int tempRotStatLft=rotate(lft);
        if (tempRotStatDwn!=-5 && tempRotStatLft!=-5)
          {
          refresh=true;
          currentRotate++;
          if (currentRotate>=4) currentRotate=0;
          tetUD+=tempRotStatDwn;
          tetLR+=tempRotStatLft;
          }
        }
      prevRot++;
      if (prevRot>waitRotateAgain) prevRot=0;
      }
    else
      {
      prevRot=0;
      }
    if (ButtonPressed(BtnMoveL))
      {
      lockDelay=0;
      prevLft++;
      if ((prevLft>=waitSlowMove || prevLft<0) && move(lft))
        {
        if (prevLft<0) prevLft=0;
        else prevLft=waitSlowMove-waitFastMove;
        tetLR++;
        refresh=true;
        }
      }
    else
      {
      prevLft=-5;
      }
    if (ButtonPressed(BtnMoveR))
      {
      lockDelay=0;
      prevRht++;
      if ((prevRht>=waitSlowMove || prevRht<0) && move(rht))
        {
        if (prevRht<0) prevRht=0;
        else prevRht=waitSlowMove-waitFastMove;
        tetLR--;
        refresh=true;
        }
      }
    else
      {
      prevRht=-5;
      }
    }

  TextOut(25,48," OUTPUT",0);
//OUTPUT
  if (INallowOutput) //Gravity and Drop
    {
    //TextOut(25,48,"CODE RUNNING",0);
    if ((INwaited%waitGravity<=prevWaited%waitGravity) || drop==dropHard || drop==dropSoft)
      {
      refresh=true;
      TextOut(25,48,"DRP/GRAV",0);
      if (drop==dropHard)              //HARD DROP
        {
        bool tempLoop=true;
        while (tempLoop)
          {
          if (move(dwn)) tetUD--;
          else
            {
            tempLoop=false;
            lockDelay++;
            if (lockDelay>=waitLock) temppiecemoving=false;
            }
          }
        }
      else                             //SOFT DROP or GRAVITY
        {
        if (move(dwn)) {tetUD--;}
        else lockDelay++;
        if (lockDelay>=waitLock) {temppiecemoving=false; lockDelay=0;}
        }
      }
    prevWaited=INwaited;
    if (readHigh(accesshigh)>score)
      {
      writeHigh(accesshigh,score);
      highMade=true;
      }
    }
  TextOut(25,48,"  DRAW  ",0);
//DRAW
  if (INallowDraw)
    {
    if (refresh) ClearScreen();
    int keepUD=tetUD;
    bool tempLoop=1;
    while (tempLoop)
      {
      if (move(dwn)) tetUD--;
      else
        {
        tempLoop=false;
        displayTetromino(currentPiece,currentRotate,tetLR*blksz,tetUD*blksz,2);
        }
      }
    tetUD=keepUD;
    //AREA
    int i;
    int j;
    for (i=0; i<height; i++)
      {
      for (j=0; j<width; j++)
        {
        if (area[j][i]) RectOut(i*blksz,j*blksz,blksz,blksz,32); //replace 32 W/ area[j][i]*28+4
        }
      }
    //NEXT PIECES / MESSAGE
    if (disp=="")
      {
      TextOut(msgX,msgY,"       ",0);
      for (i=0; i<previewPieces; i++)
        {              //    tet      rot      lr          ud       draw
        displayTetromino(nextPiece[i], 0, 64-4*blksz, 80-(3*blksz*i), 1); ////////////////////////////////////////////////
        }
      }
    else
      {
      TextOut(msgX,msgY,disp,0);
      disp="";
      }
    //CURRENT TETROMINO / SCORE
    displayTetromino(currentPiece,currentRotate,tetLR*blksz,tetUD*blksz,1);
    RotatedNumbersOut(SX,SY,score);
    }

  return temppiecemoving;
  }


//  END   _ _        __
//         |     /  /  \
//         |    /   |  |
//        _|_  /    \__/
//       ================


void initArrays()
  {
  for (int i=0; i<height; i++)
    {
    for (int j=0; j<width; j++)
      {
      area[j][i]=0;
      }
    }
  for (int i=0; i<3; i++)
    {
    int pieceToCreate=prob;
    int rndm=Random(chnc[prob]);
    int add=0;
    for (int j=0; (j<=Ztet)&&(pieceToCreate==prob); j++)
      {
      add+=chnc[j];
      if (add>rndm) pieceToCreate=j*4;
      }
    if (pieceToCreate==prob)
      {
      ClearScreen();
      TextOut(0,24,StrCat("add  ",NumToStr(add) ),0);
      TextOut(0,16,StrCat("rndm ",NumToStr(rndm)),0);
      TextOut(0,00,"piece create err",0);
      PlayTone(2000,1000);Wait(1000);
      }
    nextPiece[i]=pieceToCreate;
    }
  }
  

bool pieceCreate()
  {
  tetLR=width/2-2;
  tetUD=height+2;
  currentRotate=0;
  int pieceToCreate=prob;
  int rndm=Random(chnc[prob]);
  int add=0;
  for (int j=0; (j<=Ztet)&&(pieceToCreate==prob); j++)
    {
    add+=chnc[j];
    if (add>rndm) pieceToCreate=j*4;
    }
  if (pieceToCreate==prob)
    {
    ClearScreen();
    TextOut(0,24,StrCat("add  = ",NumToStr(add)) ,0);
    TextOut(0,16,StrCat("rndm = ",NumToStr(rndm)),0);
    TextOut(0,00,"piece create err",0);
    PlayTone(2000,1000);Wait(1000);
    }
  currentPiece=nextPiece[0];
  for (int i=1; i<previewPieces-1; i++)
    {
    //PlayTone(1000,500);Wait(500);
    nextPiece[i-1]=nextPiece[i];
    }
  nextPiece[previewPieces-1]=pieceToCreate;
  }


void pieceSetInto()
  {
  int tempLR,tempUD;
  for (int i=0; i<4; i++)
    {
    tempLR=tet[currentPiece+currentRotate][i  ]+tetLR;
    tempUD=tet[currentPiece+currentRotate][i+4]+tetUD;
    area[tempLR][tempUD]=1;
    }
  }
  
  
int clearFullRows()
  {
  int blocksInRow=0;
  int numOfFilledLines=0;
  int i,j,k;
  for (i=0; i<height+2; i++)                //Check All Rows
    {
    blocksInRow=0;
    for (j=0; j<width; j++)                 //Add up blocks in row
      {
      blocksInRow+=(area[j][i]);
      }
    if (blocksInRow==width&&i<height)       //If (row_is_full)
      {
      for (k=i; k<height; k++)              //Move higher rows down
        {
        for (j=0; j<width; j++)
          {
          int temp=area[j][k];
          SendResponseNumber(9,temp);
          area[j][k]=area[j][k+1];
          }
        }
      i--; //redo row if it gets destroyed
      numOfFilledLines++;
      }
    else if (blocksInRow>0&&i>=height)
      {
      alive=false;
      }
    }

  //add to score
  if      (numOfFilledLines==1)    {score+=100; prevQuadClear=false; disp="Single!";}
  else if (numOfFilledLines==2)    {score+=200; prevQuadClear=false; disp="Double!";}
  else if (numOfFilledLines==3)    {score+=400; prevQuadClear=false; disp="Triple!";}
  else if (numOfFilledLines==4)
  {if (prevQuadClear) {score+=400;} score+=800; prevQuadClear=true;  disp="Tetris!";}
  return numOfFilledLines;
  }

  
bool gameEnd()
  {
  bool tempplayagain=false;
  TextOut(0,0,"GamOvr!",4096);
  PlayTone(1500,1000);
  Wait(1000);
  ClearScreen();
  TextOut(30,36,"Rotate NXT",0);
  Wait(1000);
  if (highMade) writeHighName(accesshigh,score);
  ClearScreen();
  string show=NumToStr(score);
  TextOut(0,LCD_LINE6,StrCat("S:",show),0);
  //TextOut(0,LCD_LINE7,StrCat("HS:",NumToStr( readHigh(readme) )),0);  //append code
  show=readHighName(accesshigh);
  TextOut(0,LCD_LINE8,StrCat("N:",show),0);
  return tempplayagain;
  }

// BEGIN  _    __   __          __
//       | \  |    |  )  |  |  /  \
//       | |  |--  |-<   |  |  |  __
//       |_/  |__  |__)  \__/  \__/
//      ============================

void debugStream(int INint)
  {
  //viewDbg=inInt%5;
  bool insideLoop=true;
  while (insideLoop)
    {
    viewDbg++;
    if (viewDbg>4) viewDbg=0;
    if (allowDbg[viewDbg]) insideLoop=false;
    }
  string str1="";
  string str2="";
  string str3="";
  string str4="";
  string str5="";
  string msg1="";
  string msg2="";
  string msg3="";
  string msg4="";
  string msg5="";
  string result;
  if      (viewDbg==0)
    {
    str1=disp;
    str2=accesshigh;
    str3=NumToStr(speedup);
    str4=NumToStr(INint);
    msg1="  dsp ";
    msg2="  ahi ";
    msg3="  sdp ";
    msg4="    i ";
    }
  else if (viewDbg==1)
    {
    str1=NumToStr(score);
    str2=NumToStr(gametype);
    str3=NumToStr(gamespeed);
    str4=NumToStr(delaytime);
    str5=NumToStr(lockDelay);
    msg1="  sc ";
    msg2="  gt ";
    msg3="  gs ";
    msg4="  dt ";
    msg4="  lD ";
    }
  else if (viewDbg==2)
    {
    str1=NumToStr(prevWaited);
    str2=NumToStr(prevLft);
    str3=NumToStr(prevRht);
    str4=NumToStr(prevDrp);
    str5=NumToStr(prevRot);
    msg1="  pW ";
    msg2="  pL ";
    msg3="  pR ";
    msg4="  pD ";
    msg5="  pR ";
    }
  else if (viewDbg==3)
    {
    str1=NumToStr(currentPiece);
    str2=NumToStr(currentRotate);
    str3=NumToStr(tetLR);
    str4=NumToStr(tetUD);
    msg1="  cP ";
    msg2="  cR ";
    msg3="  tL ";
    msg4="  tU ";
    }
  else if (viewDbg==4)
    {
    str1=NumToStr(drop);
    str2=NumToStr(alive);
    str3=NumToStr(prevQuadClear);
    str4=NumToStr(highMade);
    msg1="  dp ";
    msg2="  lv ";
    msg3="  pQ ";
    msg4="  hM ";
    }
  result=StrCat(msg1,str1,msg2,str2,msg3,str3,msg4,str4);
  SendResponseString(9,result);
  Wait(60);
  }


void debug(int INmode)
  {
  prevQuadClear=false;
  prevLft=0;
  prevRht=0;
  selectGame(1);
  initArrays();
  score=Random(INT_MAX-10000)+10000;
  ClearScreen();
  
  if (INmode==2) //ClearFullRows()
    {
    for (int i=0; i<height; i++)
      {
      for (int j=0; j<width; j++)
        {
        area[j][i]=(Random(8)!=0);
        }
      }
    //PlayTone(1000,800);Wait(1000);
    inputOutput(false,false,true,0);
    Wait(3000);
    int i=clearFullRows();
    ClearScreen();
    Wait(250);
    inputOutput(false,false,true,0);
    NumOut(0,48,i,0);
    while(1){}
    }
    
  else if (INmode==3) //displayTetromino()
    {
    int tets,angl,k;
    for (tets=0; tets<7; tets++)
      {
      for (angl=0; angl<4; angl++)
        {
        ClearScreen();
        displayTetromino(tets*4,angl,0,0,0);//////////////////////////////////////////////////////////////////////
        Wait(500);
        until (!ButtonPressed(3)){}
        }
      }
    }

  else if (INmode==4) //peiceSetInto()
    {
    pieceCreate();
    tetUD=10;
    pieceSetInto();
    inputOutput(false,false,true,0);
    Wait(3000);
    debugStream(0);
    ClearScreen();
    displayTetromino(currentPiece,currentRotate,tetLR*blksz,tetUD*blksz,1);///////////////////////////////////////
    Wait(500);
    inputOutput(false,false,true,0);
    Wait(3000);
    }
  else if (INmode==5) //peiceCreate()
    {
    while (1)
      {
      pieceCreate();
      ClearScreen();
      NumOut(0,48,currentPiece,4096);
      NumOut(0,40,nextPiece[0],4096);
      NumOut(0,32,nextPiece[1],4096);
      NumOut(0,24,nextPiece[2],4096);
      Wait(400);
      }
    }
  else if (INmode==6) //gravity
    {
    pieceCreate();
    while(1)
      {
      ClearScreen();
      inputOutput(false,false,true,0);
      Wait(1000);
      tetUD--;
      }
    }
  }

//  END   _    __   __          __
//       | \  |    |  )  |  |  /  \
//       | |  |--  |-<   |  |  |  __
//       |_/  |__  |__)  \__/  \__/
//      ============================
  
//Modes:
//0  normal
//1  fast
//2  debug clearFullRows()
//3  dubug rotation
//4  debug peiceSetInto()
//5  debug peiceCreate()
//6  debug gravity in inputOutput()
  
task main()
  {
  int mode=defaultmode;
  while (!ButtonPressed(3))
    {
    mode=senseButton(mode,true,1,6,false);
    NumOut(48,0,mode,0);
    }
  until (!ButtonPressed(3)) {}
  if (mode==0||mode==1)
    {
    ClearScreen();
    SetLongAbort(true);
    selectGame(1);
    bool playagain;
    bool piecemoving;
    playagain=true;
    while (playagain)
      {
      initArrays();
      selectGame(mode);
      alive=true;
      while (alive)
        {
        pieceCreate();
        alive=move(sty); //if piece was made where the board is full, end the game
        piecemoving=alive;
        for (int i=0; piecemoving; i++) //waiting
          {
          piecemoving=inputOutput(true,true,true,i);
          Wait(10); //debugStream(i);
          }
        delaytime*=speedup;
        pieceSetInto();
        clearFullRows();
        }
      playagain=gameEnd();
      }
    }
  else
    {
    debug(mode);
    }
  }

/*
Process Order:
-Rotation
-Move
-Drop
-Gravity

Hold piece              NEVER
Firm Drop               NEVER

Soft Drop               DONE
Hard Drop               DONE
Clockwise Rotation      DONE
Right Side Bias         DONE
Delayed Auto Shift      DONE

Wall kicks              BUGGY, "I" won't kick 2 over

Allow only 1 floor kick                                IMPLEMENT
Allow I wall kicking always.                           IMPLEMENT
Allow I floor kicking even when not touching ground    IMPLEMENT

Adhere to SRS guidelines, some ARS guidelines
  http://tetris.wikia.com/wiki/ARS
  http://tetris.wikia.com/wiki/SRS

*/
