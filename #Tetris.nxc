//Tetris
//Joseph Dykstra


/*              PREPROCESSOR              */
#include "+Button+-.nxc"
#include "+Highscore.nxc"
#include "+RotatedNumbers.nxc"
//Dimensions / Graphics
#define b       4
#define width   10
#define height  25
#define TX      35
#define SX      94
#define SY      61
#define previewPieces   3
//Timing (all *10)
#define waitGravity     50
#define waitFastMove    10
#define waitRotateAgain 10
#define waitHardDrop    10
#define waitLock        50
#define fastRepeat      5
//More
#define dwn 0
#define lft 1
#define rht 2
//Tetriminos
#define Itet 0
#define Jtet 1
#define Ltet 2
#define Otet 3
#define Stet 4
#define Ttet 5
#define Ztet 6
#define prob 7


//                 GLOBAL CONSTANTS
const short tet[8][28]=
  {
// I
  {0,1,2,3,
   1,1,1,1}
  {2,2,2,2,
   0,1,2,3}
  {0,1,2,3,
   2,2,2,2}
  {1,1,1,1,
   0,1,2,3}

// J
  {0,1,2,0,
   1,1,1,0}
  {1,1,1,2,
   0,1,2,0}
  {0,1,2,2,
   1,1,1,2}
  {1,1,1,0,
   0,1,2,2}

// L
  {0,1,2,2,
   1,1,1,0}
  {1,1,1,2,
   0,1,2,2}
  {0,0,1,2,
   2,1,1,1}
  {0,1,1,1,
   0,0,1,2}

// O
  {1,1,2,2,
   0,1,0,1}
  {1,1,2,2,
   0,1,0,1}
  {1,1,2,2,
   0,1,0,1}
  {1,1,2,2,
   0,1,0,1}

// S
  {2,1,1,0,
   0,0,1,1}
  {1,1,2,2,
   0,1,1,2}
  {2,1,1,0,
   1,1,2,2}
  {0,0,1,1,
   0,1,1,2}

//T
  {0,1,1,2,
   1,1,0,1}
  {1,1,2,1,
   0,1,1,2}
  {0,1,1,2,
   1,1,2,1}
  {1,1,0,1,
   0,1,1,2}
   
// Z
  {0,1,1,2,
   0,0,1,1}
  {1,1,2,2,
   2,1,1,0}
  {0,1,1,2,
   1,1,2,2}
  {0,0,1,1,
   2,1,1,0}
  };


//                 GLOBAL VARIABLES
string msg;
string disp;
string accesshigh;
float speedup;
int score;
int gametype;
int gamespeed;
int delaytime;
int prevC;
int prevE;
int prevL;
int prevR;
int currentPiece;
int currentRotate;
int prevWaited;
int tetX;
int tetY;
int lockDelay;
bool alive;
bool moveL;
bool moveR;
bool rotate;
bool drop;
bool prevQuadClear;
bool highMade=false;


bool area[width][height+2];
int chnc[8];
int nextPiece[previewPieces];


//                 SUBROUTINES
void selectGame(bool fastmode)
  {
  prevQuadClear=false;
  prevC=0;
  prevE=0;
  score=0;
  currentPiece=-1;
  disp="       ";
  
  if (fastmode)
    {
    speedup=0.9;
    delaytime=400;
    accesshigh="TetrisFastGive.dat";
    chnc[Itet]=2;
    chnc[Jtet]=1;
    chnc[Ltet]=1;
    chnc[Otet]=2;
    chnc[Stet]=0;
    chnc[Ttet]=1;
    chnc[Ztet]=0;
    chnc[prob]=7;
    }
  else
    {
    accesshigh="Tetris";
    while (ButtonPressed(BTNRIGHT)==false)
      {
      gamespeed=senseButton(gamespeed,false,1,2,false);
      ClearScreen();
      TextOut(TX,LCD_LINE1,"TETRIS", 0);
      TextOut(2, LCD_LINE2,"Speed:", 0);
      TextOut(2, LCD_LINE3,"Slow",   0);
      TextOut(2, LCD_LINE4,"Medium", 0);
      TextOut(2, LCD_LINE5,"Fast",   0);
      TextOut(88,LCD_LINE8,"OK",     0);
      RectOut(0,40-(gamespeed*8),49,8,0);
      Wait(50);
      }
    TextOut(TX,LCD_LINE1,"TETRIS",  0);
    until (ButtonPressed(BTNRIGHT)==false) {}
    while (ButtonPressed(BTNRIGHT)==false)
      {
      gametype=senseButton(gametype,false,1,4,false);
      ClearScreen();
      TextOut(TX,LCD_LINE1,"TETRIS",   0);
      TextOut(2, LCD_LINE2,"Type:",    0);
      TextOut(2, LCD_LINE3,"Giveaway", 0);
      TextOut(2, LCD_LINE4,"Simple",   0);
      TextOut(2, LCD_LINE5,"Normal",   0);
      TextOut(2, LCD_LINE6,"Hard",     0);
      TextOut(2, LCD_LINE7,"Death",    0);
      TextOut(88,LCD_LINE8,"OK", 0);
      RectOut(0,40-(gametype*8),49,8,0);
      Wait(50);
      }
    TextOut(TX,LCD_LINE1,"TETRIS",  0);
    until (ButtonPressed(BTNRIGHT)==false) {}
    //
    if      (gamespeed==0)
      {
      accesshigh=StrCat(accesshigh,"Slow");
      speedup=0.975;
      delaytime=800;
      }
    else if (gamespeed==1)
      {
      accesshigh=StrCat(accesshigh,"Med");
      speedup=0.9375;
      delaytime=600;
      }
    else if (gamespeed==2)
      {
      accesshigh=StrCat(accesshigh,"Fast");
      speedup=0.9;
      delaytime=400;
      }

    if      (gametype==0)
      {
      accesshigh=StrCat(accesshigh,"Give.dat");
      chnc[Itet]=2;
      chnc[Jtet]=1;
      chnc[Ltet]=1;
      chnc[Otet]=2;
      chnc[Stet]=0;
      chnc[Ttet]=1;
      chnc[Ztet]=0;
      chnc[prob]=7;
      }
    else if (gametype==1)
      {
      accesshigh=StrCat(accesshigh,"Simp.dat");
      chnc[Itet]=3;
      chnc[Jtet]=1;
      chnc[Ltet]=1;
      chnc[Otet]=3;
      chnc[Stet]=1;
      chnc[Ttet]=2;
      chnc[Ztet]=1;
      chnc[prob]=12;
      }
    else if (gametype==2)
      {
      accesshigh=StrCat(accesshigh,"Norm.dat");
      chnc[Itet]=1;
      chnc[Jtet]=1;
      chnc[Ltet]=1;
      chnc[Otet]=1;
      chnc[Stet]=1;
      chnc[Ttet]=1;
      chnc[Ztet]=1;
      chnc[prob]=7;
      }
    else if (gametype==3)
      {
      accesshigh=StrCat(accesshigh,"Hard.dat");
      chnc[Itet]=2;
      chnc[Jtet]=3;
      chnc[Ltet]=3;
      chnc[Otet]=2;
      chnc[Stet]=4;
      chnc[Ttet]=3;
      chnc[Ztet]=4;
      chnc[prob]=21;
      }
    else if (gametype==4)
      {
      accesshigh=StrCat(accesshigh,"Death.dat");
      chnc[Itet]=1;
      chnc[Jtet]=3;
      chnc[Ltet]=3;
      chnc[Otet]=2;
      chnc[Stet]=4;
      chnc[Ttet]=2;
      chnc[Ztet]=4;
      chnc[prob]=19;
      }
    ClearScreen();
    }
  }

//  ______   ______   ______   ______   ______   ______   ______   ______
//  |__  _|  |__  _|  |__  _|  |__  _|  |__  _|  |__  _|  |__  _|  |__  _|
//  _  ||    _  ||    _  ||    _  ||    _  ||    _  ||    _  ||    _  ||
//  \\_//    \\_//    \\_//    \\_//    \\_//    \\_//    \\_//    \\_//
//   \_/      \_/      \_/      \_/      \_/      \_/      \_/      \_/


int move(int dir)
  {
  if (dir==dwn)
    {
    
    }
  if (dir==lft)
    {

    }
  if (dir==rht)
    {

    }
  }
  

void inputOutput(bool allowInput, int waited)
  {
  if (allowInput)
    {
    /////  -  INPUT  -  /////
    if (ButtonPressed(BTNLEFT))
      {
      if (prevL==0)
        {
        drop=true;
        }
      prevL++;
      if (prevL<waitHardDrop)
        {
        prevL=0;
        }
      }
    if (ButtonPressed(BTNRIGHT))
      {
      if (prevR==0)
        {
        rotate=true;
        }
      prevR++;
      if (prevR<waitRotateAgain)
        {
        prevR=0;
        }
      }
    if (ButtonPressed(BTNCENTER))
      {
      if (prevC==0)
        {
        moveL=true;
        }
      prevC++;
      if (prevC<waitFastMove)
        {
        prevC=waitFastMove-fastRepeat;
        }
      }
    if (ButtonPressed(BTNEXIT))
      {
      if (prevE==0)
        {
        moveR=true;
        }
      prevE++;
      if (prevE<waitFastMove)
        {
        prevE=waitFastMove-fastRepeat;
        }
      }
    }
  /////  -   OUTPUT   -  /////
  if (rotate)
    {
    //ROTATE CODE
    rotate=false;
    }
  if (moveL)
    {
    tetX--;
    //if (tetX<0) tetX=0;
    moveL=false;
    }
  if (moveR)
    {
    //Checks the X position, not the bounding box...
    tetX++;
    //if (tetX>width) tetX=width;
    moveR=false;
    }
  //Gravity
  if (waited%waitGravity<prevWaited%waitGravity)
    {
    tetY--;
    }

  prevWaited=waited;
  /////   -   DRAW   -   /////
  int i;
  int j;
  for (i=0; i<height; i++)
    {
    for (j=0; j<width; j++)
      {
      //RectOut(i*b,j*b,b,b,( (area[j][i]*28) +4));
      if (area[j][i]) RectOut(i*b,j*b,b,b,32);
      }
    }
  if (disp=="")
    {
    for (i=0; i<previewPieces; i++)
      {
      //display nextPiece[i]
      }
    TextOut(0,56,"       ",0);
    }
  TextOut(0,56,disp,0);
  disp="";


  RotatedNumbersOut(SX,SY,score);


  if (readHigh(accesshigh)>score)
    {
    writeHigh(accesshigh,score);
    highMade=true;
    }
  }
  

void pieceCreate()
  {
  int rndm;
  int pieceToCreate=0;
  rndm=Random(chnc[prob]);
  for (int i=0; (i<Ztet)&&(pieceToCreate==0); i++)
    {
    if (rndm<chnc[i])
      {
      pieceToCreate=i;
      }
    }
  currentPiece=nextPiece[0];
  nextPiece[0]=nextPiece[1];
  nextPiece[1]=nextPiece[2];
  nextPiece[2]=pieceToCreate;
  }
  
  
int clearFullRows()   //////////////////// - - FIX - - ////////////////////
  {
  int blocksInRow=0;
  int numOfFilledLines=0;
  int i,j,k;
  for (i=0; i<height+2; i++)          //Check All Rows
    {
    blocksInRow=0;
    for (j=0; j<width; j++)         //add up blocks in row
      {
      blocksInRow+=(area[j][i]);
      }

    if (blocksInRow==width&&i<height)         //if the row is full
      {
      for (k=i; k<height; k++)      //move higher rows down
        {
        for (j=0; j<width; j++)
          {
          int temp=area[j][k];
          SendResponseNumber(9,temp);
          area[j][k]=area[j][k+1];   //100, fi, 26
          //area[j][k]=area[j+1][k]; //10,  fi, ??
          //area[k][j]=area[k][j+1]; //100, fi, ??
          //area[k][j]=area[k+1][j]; //90,  fi, ??
          }
        }
      i--; //redo row if it gets destroyed (because area[a][b]=area[a][b+1] broke, infinite loop)
      numOfFilledLines++;
      }
    else if (blocksInRow>0&&i>=height)
      {
      alive=false;
      }
    //PlayTone(1000,200);
    //Wait(250);
    }

  //add to score
  if      (numOfFilledLines==1)    {score+=100; prevQuadClear=false; disp="Single!";}
  else if (numOfFilledLines==2)    {score+=200; prevQuadClear=false; disp="Double!";}
  else if (numOfFilledLines==3)    {score+=400; prevQuadClear=false; disp="Triple!";}
  else if (numOfFilledLines==4)
    {
    if (!prevQuadClear)   {score+=800;  prevQuadClear=true; disp="Tetris!";}
    else                  {score+=1200; prevQuadClear=true; disp="Cnsctv!";}
    }
  return numOfFilledLines;
  }

  
void gameEnd()
  {
  TextOut(0,0,"GamOvr!",4096);
  PlayTone(1500,1000);
  Wait(1000);
  ClearScreen();
  TextOut(30,36,"Rotate...",4096);
  Wait(1000);
  if (highMade) writeHighName(accesshigh,score);
  ClearScreen();
  string show=NumToStr(score);
  TextOut(0,LCD_LINE6,StrCat("S:",show),0);
  //TextOut(0,LCD_LINE7,StrCat("HS:",NumToStr( readHigh(readme) )),0);  //append code
  show=readHighName(accesshigh);
  TextOut(0,LCD_LINE8,StrCat("N:",show),0);
  }


void debug(int mode)
  {
  if (mode==2) //ClearFullRows
    {
    for (int i=0; i<height; i++)
      {
      for (int j=0; j<width; j++)
        {
        area[j][i]=(Random(8)!=0);
        }
      }
    prevQuadClear=false;
    prevC=0;
    prevE=0;
    score=Random(INT_MAX-10000)+10000;//score=0;
    currentPiece=-1;
    ClearScreen();
    inputOutput(false,0);
    Wait(3000);
    int i=clearFullRows();
    ClearScreen();
    Wait(250);
    inputOutput(false,0);
    NumOut(0,48,i,0);
    while(1){}
    }

  else if (mode==3) //Rotation
    {
    for (int i=0; i<height; i++)
      {
      for (int j=0; j<width; j++)
        {
        area[j][i]=0;
        }
      }
    int tets,angl,k;
    for (tets=0; tets<28; tets++)
      {
      for (angl=0; angl<4; angl++)
        {
        ClearScreen();
        TextOut(0,0,"I",0);
        for(k=0;k<4;k++)
          {RectOut(tet[angl][tets]*8, 56-tet[angl][tets+4]*8, 8,8, 32);}
        Wait(500);
        until (!ButtonPressed(3)){}
        }
      }
    }

  else if (mode==4)
    {
    //idk
    }
  }
  

task main()
  {
  int mode=3;
  //modes:
  //0  normal
  //1  fast
  //2  debug clearFullRows()
  //3  dubug rotation
  if (mode==0||mode==1)
    {
    SetLongAbort(true);
    bool playagain, piecemoving;
    for (int i=0; i<height; i++)
      {
      for (int j=0; j<width; j++)
        {
        area[j][i]=(Random(3)+1)%2;
        //area[j][i]=0;
        }
      }
    playagain=true;
    while (playagain)
      {
      selectGame(mode);
      alive=true;
      while (alive)
        {
        pieceCreate();
        piecemoving=true;
        for (int i=0;piecemoving; i++) //waiting
          {
          inputOutput(true,i);
          Wait(10);
          //debugging
          }
        //set piece into area
        clearFullRows();
        }
      gameEnd();
      }
    }
  else
    {
    debug(mode);
    }
  }
  
/*
IMPLEMENT:
Draw current tetromino (hollow rectangles)
Draw ghost tetromino (hollow rectangles or circles?)
Draw 3 pieces tetromino preview
Fix Line Clearing
Rotation
Process Order:
  Rotation
  Move/Drop
  Gravity


Soft Drop
Firm Drop-NO
Hard Drop
Delayed Auto Shift
Wall kicks
Clockwise Rotation
Hold piece-NO
Right Side Bias
Allow only 1 floor kick
Allow I wall kicking always.
Allow I floor kicking even when not touching ground, (does not count?)
Adhere to SRS guidelines, some ARS guidelines
  http://tetris.wikia.com/wiki/SRS
  http://tetris.wikia.com/wiki/ARS

*/

/*
const int I[8][4]=
  {
  {0,1,2,3,
   1,1,1,1}
  {2,2,2,2,
   0,1,2,3}
  {0,1,2,3,
   2,2,2,2}
  {1,1,1,1,
   0,1,2,3}
  };
const int J[8][4]=
  {
  {0,1,2,0,
   1,1,1,0}
  {1,1,1,2,
   0,1,2,0}
  {0,1,2,2,
   1,1,1,2}
  {1,1,1,0,
   0,1,2,2}
  };
const int L[8][4]=
  {
  {0,1,2,2,
   1,1,1,0}
  {1,1,1,2,
   0,1,2,2}
  {0,0,1,2,
   2,1,1,1}
  {0,1,1,1,
   0,0,1,2}
  };
const int O[8][4]=
  {
  {1,1,2,2,
   0,1,0,1}
  {1,1,2,2,
   0,1,0,1}
  {1,1,2,2,
   0,1,0,1}
  {1,1,2,2,
   0,1,0,1}
  };
const int S[8][4]=
  {
  {2,1,1,0,
   0,0,1,1}
  {1,1,2,2,
   0,1,1,2}
  {2,1,1,0,
   1,1,2,2}
  {0,0,1,1,
   0,1,1,2}
  };
const int T[8][4]=
  {
  {0,1,1,2,
   1,1,0,1}
  {1,1,2,1,
   0,1,1,2}
  {0,1,1,2,
   1,1,2,1}
  {1,1,0,1,
   0,1,1,2}
  };
const int Z[8][4]=
  {
  {0,1,1,2,
   0,0,1,1}
  {1,1,2,2,
   2,1,1,0}
  {0,1,1,2,
   1,1,2,2}
  {0,0,1,1,
   2,1,1,0}
  };
*/
