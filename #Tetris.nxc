//Tetris
//Joseph Dykstra


/*              PREPROCESSOR              */
#include "+Button+-.nxc"
#include "+Highscore.nxc"
#include "+RotatedNumbers.nxc"
//Dimensions / Graphics
#define blksz   4
#define width   10
#define height  25
#define TX      35
#define SX      94
#define SY      61
#define previewPieces   3
//Timing (all *10)
#define waitGravity     5
#define waitFastMove    3
#define waitRotateAgain 3
#define waitHardDrop    3
#define waitLock        5
#define fastRepeat      5
//Move()
#define dwn 0
#define lft 1
#define rht 2
//Drop
#define dropHard  1  //Normal
#define dropSoft  2  //Normal
#define dropWHard 3  //Wait
#define dropWSoft 4  //Wait
//Tetriminos
#define Itet 0
#define Jtet 1
#define Ltet 2
#define Otet 3
#define Stet 4
#define Ttet 5
#define Ztet 6
#define prob 7


//                 GLOBAL CONSTANTS
const short tet[8][28]=
  {
// I
  {0,1,2,3,
   1,1,1,1}
  {2,2,2,2,
   0,1,2,3}
  {0,1,2,3,
   2,2,2,2}
  {1,1,1,1,
   0,1,2,3}
// J
  {0,1,2,0,
   1,1,1,0}
  {1,1,1,2,
   0,1,2,0}
  {0,1,2,2,
   1,1,1,2}
  {1,1,1,0,
   0,1,2,2}
// L
  {0,1,2,2,
   1,1,1,0}
  {1,1,1,2,
   0,1,2,2}
  {0,0,1,2,
   2,1,1,1}
  {0,1,1,1,
   0,0,1,2}
// O
  {1,1,2,2,
   0,1,0,1}
  {1,1,2,2,
   0,1,0,1}
  {1,1,2,2,
   0,1,0,1}
  {1,1,2,2,
   0,1,0,1}
// S
  {2,1,1,0,
   0,0,1,1}
  {1,1,2,2,
   0,1,1,2}
  {2,1,1,0,
   1,1,2,2}
  {0,0,1,1,
   0,1,1,2}
//T
  {0,1,1,2,
   1,1,0,1}
  {1,1,2,1,
   0,1,1,2}
  {0,1,1,2,
   1,1,2,1}
  {1,1,0,1,
   0,1,1,2}
// Z
  {0,1,1,2,
   0,0,1,1}
  {1,1,2,2,
   2,1,1,0}
  {0,1,1,2,
   1,1,2,2}
  {0,0,1,1,
   2,1,1,0}
  };


//                 GLOBAL VARIABLES
string msg         ="";
string disp        ="";
string accesshigh  ="";
float speedup      = 0;
int score          = 0;
int gametype       = 0;
int gamespeed      = 0;
int delaytime      = 0;
int lockDelay      = 0;
int prevC          = 0;
int prevE          = 0;
int prevL          = 0;
int prevR          = 0;
int currentPiece   = 0;
int currentRotate  = 0;
int prevWaited     = 0;
int tetX           = 0;
int tetY           = 0;
int drop           = 0;
int viewDbg        = 0;
bool alive         = 0;
bool prevQuadClear = 0;
bool highMade      = 0;


bool area[width][height+2];
int chnc[8];
int nextPiece[previewPieces];


//                 SUBROUTINES
void selectGame(bool fastmode)
  {
  prevQuadClear=false;
  prevC=0;
  prevE=0;
  score=0;
  //currentPiece=-1; //why -1?
  disp="";
  accesshigh="Tetris";
  if (fastmode)
    {
    gamespeed=0;
    gametype=2;
    }
  else
    {
    while (ButtonPressed(BTNRIGHT)==false)
      {
      gamespeed=senseButton(gamespeed,false,1,2,false);
      ClearScreen();
      TextOut(TX,LCD_LINE1,"TETRIS", 0);
      TextOut(2, LCD_LINE2,"Speed:", 0);
      TextOut(2, LCD_LINE3,"Slow",   0);
      TextOut(2, LCD_LINE4,"Medium", 0);
      TextOut(2, LCD_LINE5,"Fast",   0);
      TextOut(88,LCD_LINE8,"OK",     0);
      RectOut(0,40-(gamespeed*8),49,8,0);
      Wait(50);
      }
    TextOut(TX,LCD_LINE1,"TETRIS",  0);
    until (ButtonPressed(BTNRIGHT)==false) {}
    while (ButtonPressed(BTNRIGHT)==false)
      {
      gametype=senseButton(gametype,false,1,4,false);
      ClearScreen();
      TextOut(TX,LCD_LINE1,"TETRIS",   0);
      TextOut(2, LCD_LINE2,"Type:",    0);
      TextOut(2, LCD_LINE3,"Giveaway", 0);
      TextOut(2, LCD_LINE4,"Simple",   0);
      TextOut(2, LCD_LINE5,"Normal",   0);
      TextOut(2, LCD_LINE6,"Hard",     0);
      TextOut(2, LCD_LINE7,"Death",    0);
      TextOut(88,LCD_LINE8,"OK", 0);
      RectOut(0,40-(gametype*8),49,8,0);
      Wait(50);
      }
    }
  TextOut(TX,LCD_LINE1,"TETRIS",  0);
  until (ButtonPressed(BTNRIGHT)==false) {}
  //
  if      (gamespeed==0)
    {
    accesshigh=StrCat(accesshigh,"Slow");
    speedup=0.975;
    delaytime=800;
    }
  else if (gamespeed==1)
    {
    accesshigh=StrCat(accesshigh,"Med");
    speedup=0.9375;
    delaytime=600;
    }
  else if (gamespeed==2)
    {
    accesshigh=StrCat(accesshigh,"Fast");
    speedup=0.9;
    delaytime=400;
    }
  if      (gametype==0)
    {
    accesshigh=StrCat(accesshigh,"Give.dat");
    chnc[Itet]=2;
    chnc[Jtet]=1;
    chnc[Ltet]=1;
    chnc[Otet]=2;
    chnc[Stet]=0;
    chnc[Ttet]=1;
    chnc[Ztet]=0;
    chnc[prob]=7;
    }
  else if (gametype==1)
    {
    accesshigh=StrCat(accesshigh,"Simp.dat");
    chnc[Itet]=3;
    chnc[Jtet]=1;
    chnc[Ltet]=1;
    chnc[Otet]=3;
    chnc[Stet]=1;
    chnc[Ttet]=2;
    chnc[Ztet]=1;
    chnc[prob]=12;
    }
  else if (gametype==2)
    {
    accesshigh=StrCat(accesshigh,"Norm.dat");
    chnc[Itet]=1;
    chnc[Jtet]=1;
    chnc[Ltet]=1;
    chnc[Otet]=1;
    chnc[Stet]=1;
    chnc[Ttet]=1;
    chnc[Ztet]=1;
    chnc[prob]=7;
    }
  else if (gametype==3)
    {
    accesshigh=StrCat(accesshigh,"Hard.dat");
    chnc[Itet]=2;
    chnc[Jtet]=3;
    chnc[Ltet]=3;
    chnc[Otet]=2;
    chnc[Stet]=4;
    chnc[Ttet]=3;
    chnc[Ztet]=4;
    chnc[prob]=21;
    }
  else if (gametype==4)
    {
    accesshigh=StrCat(accesshigh,"Death.dat");
    chnc[Itet]=1;
    chnc[Jtet]=3;
    chnc[Ltet]=3;
    chnc[Otet]=2;
    chnc[Stet]=4;
    chnc[Ttet]=2;
    chnc[Ztet]=4;
    chnc[prob]=19;
    }
  else if (gametype==5) //DEBUG ONLY
    {
    accesshigh=StrCat(accesshigh,"Death.dat");
    chnc[Itet]=0;
    chnc[Jtet]=1;
    chnc[Ltet]=0;
    chnc[Otet]=2;
    chnc[Stet]=0;
    chnc[Ttet]=0;
    chnc[Ztet]=1;
    chnc[prob]=4;
    }
  ClearScreen();
  }

//  ______   ______   ______   ______   ______   ______   ______   ______
//  |__  _|  |__  _|  |__  _|  |__  _|  |__  _|  |__  _|  |__  _|  |__  _|
//  _  ||    _  ||    _  ||    _  ||    _  ||    _  ||    _  ||    _  ||
//  \\_//    \\_//    \\_//    \\_//    \\_//    \\_//    \\_//    \\_//
//   \_/      \_/      \_/      \_/      \_/      \_/      \_/      \_/



/*
  for (int i=0; i<4; i++)
    {
    tempX=currentPiece+currentRotate;//+tetX;
    tempY=currentPiece+currentRotate;//+tetY;
    area[tet[tempX][i]]
        [tet[tempY][i+4]]=1;
    }
*/



int move(int INdir)
  {
  int canMove=0;
  int temp=currentPiece+currentRotate;
  int addX=0;
  int addY=0;
  if      (INdir==dwn) addY=1;
  else if (INdir==lft) addX=-1;
  else if (INdir==rht) addX=1;
  for (int i=0; i<4; i++)
    {
    canMove+=(area[tet[temp][i]+addX][tet[temp][i+4]+addY]);
    }
  canMove=(canMove>0); //canMove in:  0123
  return canMove;      //canMove out: 1000
  }


int rotate()
  {
  int canRotate=0;
  int temp=currentPiece+currentRotate;
  int addR=0;
  int updown;
  int leftright;
  bool stayInLoop=true;

  if (currentRotate==3) addR=-3;
  else addR=1;

  for (updown=0; (updown<=1 && stayInLoop); updown++)
    {
    for (leftright=0; (leftright<=2 && stayInLoop);  )
      {
      canRotate=0;
      for (int i=0; i<4; i++)
        {              //switch updown and leftright?
        canRotate+=(area[tet[temp+addR][i]+leftright][tet[temp+addR][i+4]]+updown);
        }
      if (canRotate==0) stayInLoop=false;
      if      (leftright==0)  leftright=1;   //1st  Center
      else if (leftright==1)  leftright=-1;  //2nd  Right
      else if (leftright==-1) leftright=2;   //3rd  Left
      }
    }
  if (stayInLoop) canRotate=((updown*10)+(leftright+1));
  else            canRotate=-1;
  return canRotate;
  }

  
void displayTetromino(int INtet,int INangl, int INx, int INy, int drawMode)
  {
  int tempX,tempY;
  for (int i=0; i<4; i++)
    {
    tempX=   (INx+(tet[INtet+INangl][i])*blksz);
    tempY=56-(INy+(tet[INtet+INangl][i+4])*blksz);
    //tempY=INy+(tet[INtet*4+INangl][i+4])*blksz; //inverted
    //Wait(500);
    if      (drawMode==0)   RectOut(tempX,tempY, blksz,blksz, 32);
    else if (drawMode==1)   RectOut(tempX,tempY, blksz,blksz, 0);
    else if (drawMode==2) CircleOut(tempX,tempY, blksz/2,     0);
    }
  }

// BEGIN  _ _        __
//         |     /  /  \
//         |    /   |  |
//        _|_  /    \__/
//       ================

bool inputOutput(bool allowInput, bool allowOutput, bool allowDraw, int waited)
  {
  bool temppiecemoving=true; //return this
//INPUT
  if (allowInput)
    {
    if (ButtonPressed(BTNLEFT))  // DROP
      {
      if (prevL>=waitHardDrop) {lockDelay=0; drop=dropWSoft;} //Instant Hard Drop
      else              {lockDelay=waitLock; drop=dropWHard;} //Wait for Soft Drop
      prevL++;
      }
    else if (drop==dropWHard || drop==dropWSoft) drop-=2;
    if (ButtonPressed(BTNRIGHT))  // ROTATE
      {
      lockDelay=0;
      if (prevR==0)
        {
        int tempRotateStatus=rotate();
        if (tempRotateStatus!=-1)
          {
          currentRotate++;
          if (currentRotate>3) currentRotate=0;
          ////////////////////////////////////////////////////////////////////////////////////////////////////////////
          //MOVE LEFT OR RIGHT              //kick sideways
          if (tempRotateStatus>=10) tetY--; //kick down
          }
        }
      prevR++;
      if (prevR<waitRotateAgain) prevR=0;
      }
    if (ButtonPressed(BTNCENTER))  // MOVE LEFT    //////////  CRASH  //////////  CRASH  //////////  CRASH  //////////  CRASH
      {
      lockDelay=0;
      if (prevC==0 && move(lft)) tetX--;
      prevC++;
      if (prevC<waitFastMove) prevC=waitFastMove-fastRepeat; //Repeat is prob broke, prevC never goes to 0...
      }
    if (ButtonPressed(BTNEXIT))  // MOVE RIGHT
      {
      lockDelay=0;
      if (prevE==0 && move(rht)) tetX++;
      prevE++;
      if (prevE<waitFastMove)  prevE=waitFastMove-fastRepeat; //Repeat is prob broke, prevE never goes to 0...
      }
    }
    
//OUTPUT
  if (allowOutput) //Gravity and Drop
    {
    TextOut(25,48,"CODE RUNNING",0);
    if ((waited%waitGravity<=prevWaited%waitGravity) || drop==dropHard || drop==dropSoft)
      {
      TextOut(25,48,"DROP/GRAVITY",0);
      if (drop==dropHard) //hard drop
        {
        bool tempLoop=true;
        while (tempLoop)
          {
          if (move(dwn)) tetY--;
          else
            {
            tempLoop=false;
            if (lockDelay>=waitLock) temppiecemoving=false;
            }
          }
        }
      else //gravity or soft drop
        {
        TextOut(25,48,"   GRAVITY  ",0);//PlayTone(1000,1000);Wait(1000);
        if (move(dwn)) tetY--; //move(dwn) returns 0, idk why... move(dwn) returns 0, idk why... move(dwn) returns 0, idk why...
        if (lockDelay>=waitLock) temppiecemoving=false;
        }
      }
    prevWaited=waited;
    if (readHigh(accesshigh)>score)
      {
      writeHigh(accesshigh,score);
      highMade=true;
      }
    }

//DRAW
  if (allowDraw)
    {
    if (waited%10==0) ClearScreen();
    //AREA
    int i;
    int j;
    for (i=0; i<height; i++)
      {
      for (j=0; j<width; j++)
        {
        if (area[j][i]) RectOut(i*blksz,j*blksz,blksz,blksz,32); //replace 32 W/ area[j][i]*28+4
        }
      }
    //NEXT PIECES / MESSAGE
    if (disp=="")
      {
      TextOut(0,56,"       ",0);
      for (i=0; i<previewPieces; i++)
        {
        displayTetromino(nextPiece[i],0, 50-((5*blksz)*i),0,1);
        }
      }
    else
      {
      TextOut(0,56,disp,0);
      disp="";
      }
    //CURRENT TETROMINO / SCORE
    displayTetromino(currentPiece,currentRotate,tetY*blksz,tetX*blksz,1);
    RotatedNumbersOut(SX,SY,score);
    }

  return temppiecemoving;
  }


//  END   _ _        __
//         |     /  /  \
//         |    /   |  |
//        _|_  /    \__/
//       ================


void initArrays()
  {
  for (int i=0; i<height; i++)
    {
    for (int j=0; j<width; j++)
      {
      area[j][i]=0;
      }
    }
    
  for (int i=0; i<3; i++)
    {
    int pieceToCreate=prob;
    int rndm=Random(chnc[prob]);
    int add=0;
    for (int j=0; (j<=Ztet)&&(pieceToCreate==prob); j++)
      {
      add+=chnc[j];
      if (add>rndm) pieceToCreate=j*4;
      }
    if (pieceToCreate==prob)
      {
      ClearScreen();
      TextOut(0,24,StrCat("add  ",NumToStr(add) ),0);
      TextOut(0,16,StrCat("rndm ",NumToStr(rndm)),0);
      TextOut(0,00,"piece create err",0);
      PlayTone(2000,500);Wait(500);
      }
    nextPiece[i]=pieceToCreate;
    }
  }
  

void pieceCreate()
  {
  tetY=height-4; // tetY=height+2;
  tetX=width/2;
  currentRotate=0; //was -1... why?

  int pieceToCreate=prob;
  int rndm=Random(chnc[prob]);
  int add=0;
  for (int j=0; (j<=Ztet)&&(pieceToCreate==prob); j++)
    {
    add+=chnc[j];
    if (add>rndm) pieceToCreate=j*4;
    }
  if (pieceToCreate==prob)
    {
    ClearScreen();
    TextOut(0,24,StrCat("add  ",NumToStr(add) ),0);
    TextOut(0,16,StrCat("rndm ",NumToStr(rndm)),0);
    TextOut(0,00,"piece create err",0);
    PlayTone(2000,500);Wait(500);
    }
  
  currentPiece=nextPiece[0];
  for (int i=1; i<previewPieces-1; i++) ////////////////////////////////////////////////////////////////////// debug mode 5
    {
    //PlayTone(1000,500);Wait(500);
    nextPiece[i-1]=nextPiece[i];
    }
  nextPiece[previewPieces-1]=pieceToCreate;
  }


void pieceSetInto()
  {
  int tempX,tempY;
  tempX=currentPiece+currentRotate;
  tempY=currentPiece+currentRotate;
  for (int i=0; i<4; i++)
    {
    area[tet[tempX][i]+tetX][tet[tempY][i+4]+tetY]=1;
    }
  }
  
  
int clearFullRows()
  {
  int blocksInRow=0;
  int numOfFilledLines=0;
  int i,j,k;
  for (i=0; i<height+2; i++)                //Check All Rows
    {
    blocksInRow=0;
    for (j=0; j<width; j++)                 //Add up blocks in row
      {
      blocksInRow+=(area[j][i]);
      }
    if (blocksInRow==width&&i<height)       //If the row is full
      {
      for (k=i; k<height; k++)              //Move higher rows down
        {
        for (j=0; j<width; j++)
          {
          int temp=area[j][k];
          SendResponseNumber(9,temp);
          area[j][k]=area[j][k+1];   //100, fi, 26
          //area[j][k]=area[j+1][k]; //10,  fi, ??
          //area[k][j]=area[k][j+1]; //100, fi, ??
          //area[k][j]=area[k+1][j]; //90,  fi, ??
          }
        }
      i--; //redo row if it gets destroyed
      numOfFilledLines++;
      }
    else if (blocksInRow>0&&i>=height)
      {
      alive=false;
      }
    }

  //add to score
  if      (numOfFilledLines==1)    {score+=100; prevQuadClear=false; disp="Single!";}
  else if (numOfFilledLines==2)    {score+=200; prevQuadClear=false; disp="Double!";}
  else if (numOfFilledLines==3)    {score+=400; prevQuadClear=false; disp="Triple!";}
  else if (numOfFilledLines==4)
    {
    if (!prevQuadClear)   {score+=800;  prevQuadClear=true; disp="Tetris!";}
    else                  {score+=1200; prevQuadClear=true; disp="Cnsctv!";}
    }
  return numOfFilledLines;
  }

  
void gameEnd()
  {
  TextOut(0,0,"GamOvr!",4096);
  PlayTone(1500,1000);
  Wait(1000);
  ClearScreen();
  TextOut(30,36,"Rotate...",4096);
  Wait(1000);
  if (highMade) writeHighName(accesshigh,score);
  ClearScreen();
  string show=NumToStr(score);
  TextOut(0,LCD_LINE6,StrCat("S:",show),0);
  //TextOut(0,LCD_LINE7,StrCat("HS:",NumToStr( readHigh(readme) )),0);  //append code
  show=readHighName(accesshigh);
  TextOut(0,LCD_LINE8,StrCat("N:",show),0);
  }

// BEGIN  _    __   __          __
//       | \  |    |  )  |  |  /  \
//       | |  |--  |-<   |  |  |  __
//       |_/  |__  |__)  \__/  \__/
//      ============================

void debugStream(int inInt)
  {
  //viewDbg=inInt%5;
  viewDbg=3;
  /*
  if      (viewDbg==0) viewDbg=2;
  else if (viewDbg==2) viewDbg=3;
  else if (viewDbg==3) viewDbg=4;
  else if (viewDbg==4) viewDbg=2;
  */
  string str1;
  string str2;
  string str3;
  string str4;
  string str5;
  string msg1;
  string msg2;
  string msg3;
  string msg4;
  string msg5;
  string result;
  if      (viewDbg==0)
    {
    str1=disp;
    str2=accesshigh;
    str3=NumToStr(speedup);
    str4=NumToStr(inInt);
    msg1="  dsp ";
    msg2="  ahi ";
    msg3="  sdp ";
    msg4="    i ";
    result=StrCat(msg1,str1,msg2,str2,msg3,str3,msg4,str4);
    SendResponseString(9,result);
    Wait(40);
    }
  else if (viewDbg==1)
    {
    str1=NumToStr(score);
    str2=NumToStr(gametype);
    str3=NumToStr(gamespeed);
    str4=NumToStr(delaytime);
    str5=NumToStr(lockDelay);
    msg1="  sc ";
    msg2="  gt ";
    msg3="  gs ";
    msg4="  dt ";
    msg4="  lD ";
    result=StrCat(msg1,str1,msg2,str2,msg3,str3,msg4,str4,msg5,str5);
    SendResponseString(9,result);
    Wait(40);
    }
  else if (viewDbg==2)
    {
    str1=NumToStr(prevWaited);
    str2=NumToStr(prevC);
    str3=NumToStr(prevE);
    str4=NumToStr(prevL);
    str5=NumToStr(prevR);
    msg1="  lD ";
    msg2="  pC ";
    msg3="  pE ";
    msg4="  pL ";
    msg5="  pR ";
    result=StrCat(msg1,str1,msg2,str2,msg3,str3,msg4,str4,msg5,str5);
    SendResponseString(9,result);
    Wait(40);
    }
  else if (viewDbg==3)
    {
    str1=NumToStr(currentPiece);
    str2=NumToStr(currentRotate);
    str3=NumToStr(tetX);
    str4=NumToStr(tetY);
    msg1="  cP ";
    msg2="  cR ";
    msg3="  tX ";
    msg4="  tY ";
    result=StrCat(msg1,str1,msg2,str2,msg3,str3,msg4,str4);
    SendResponseString(9,result);
    Wait(40);
    }
  else if (viewDbg==4)
    {
    str1=NumToStr(drop);
    str2=NumToStr(alive);
    str3=NumToStr(prevQuadClear);
    str4=NumToStr(highMade);
    msg1="  dp ";
    msg2="  lv ";
    msg3="  pQ ";
    msg4="  hM ";
    result=StrCat(msg1,str1,msg2,str2,msg3,str3,msg4,str4);
    SendResponseString(9,result);
    Wait(40);
    }
  }


void debug(int mode)
  {
  prevQuadClear=false;
  prevC=0;
  prevE=0;
  selectGame(1);
  initArrays();
  score=Random(INT_MAX-10000)+10000;
  ClearScreen();
  
  if (mode==2) //ClearFullRows()
    {
    for (int i=0; i<height; i++)
      {
      for (int j=0; j<width; j++)
        {
        area[j][i]=(Random(8)!=0);
        }
      }
    //PlayTone(1000,800);Wait(1000);
    inputOutput(false,false,true,0);
    Wait(3000);
    int i=clearFullRows();
    ClearScreen();
    Wait(250);
    inputOutput(false,false,true,0);
    NumOut(0,48,i,0);
    while(1){}
    }
    
  else if (mode==3) //displayTetromino()
    {
    int tets,angl,k;
    for (tets=0; tets<7; tets++)
      {
      for (angl=0; angl<4; angl++)
        {
        ClearScreen();
        displayTetromino(tets*4,angl,0,0,0);
        Wait(500);
        until (!ButtonPressed(3)){}
        }
      }
    }

  else if (mode==4) //peiceSetInto()
    {
    pieceCreate();
    tetY-=10;
    pieceSetInto();
    inputOutput(false,false,true,0);
    Wait(3000);
    
    ClearScreen();
    displayTetromino(currentPiece,currentRotate,tetX*blksz,tetY*blksz,1);
    Wait(500);
    inputOutput(false,false,true,0);
    Wait(3000);
    }
  else if (mode==5) //peiceCreate()
    {
    while (1)
      {
      pieceCreate();
      ClearScreen();
      NumOut(0,48,currentPiece,4096);
      NumOut(0,40,nextPiece[0],4096);
      NumOut(0,32,nextPiece[1],4096);
      NumOut(0,24,nextPiece[2],4096);
      Wait(400);
      }
    }
  else if (mode==6) //gravity
    {
    pieceCreate();
    while(1)
      {
      inputOutput(false,false,true,0);
      Wait(1000);
      tetY--;
      }
    }
  }

//  END   _    __   __          __
//       | \  |    |  )  |  |  /  \
//       | |  |--  |-<   |  |  |  __
//       |_/  |__  |__)  \__/  \__/
//      ============================
  
//Modes:
//0  normal
//1  fast
//2  debug clearFullRows()
//3  dubug rotation
//4  debug peiceSetInto()
//5  debug peiceCreate()
//6  debug gravity in inputOutput()
  
task main()
  {
  int mode=1;
  while (!ButtonPressed(3))
    {
    mode=senseButton(mode,true,1,6,false);
    NumOut(48,0,mode,0);
    }
  until (!ButtonPressed(3)) {}
  if (mode==0||mode==1)
    {
    ClearScreen();
    SetLongAbort(true);
    selectGame(1);
    bool playagain;
    bool piecemoving;
    initArrays();
    playagain=true;
    while (playagain)
      {
      selectGame(mode);
      alive=true;
      while (alive)
        {
        pieceCreate();
        piecemoving=inputOutput(true,false,true,0);//PlayTone(500,2500);Wait(2500);
        piecemoving=true;
        for (int i=0; piecemoving; i++) //waiting
          {
          piecemoving=inputOutput(true,true,true,i);
          Wait(10);//Wait(1000);
          debugStream(i);
          }
        delaytime*=speedup;
        pieceSetInto();
        clearFullRows();
        }
      gameEnd();
      }
    }
  else
    {
    debug(mode);
    }
  }
  
/*
IMPLEMENT:
Draw current tetromino (hollow rectangles)
Draw ghost tetromino (hollow rectangles or circles?)
Draw 3 pieces tetromino preview
Fix Line Clearing
Rotation
Process Order:
  Rotation
  Move/Drop
  Gravity


Soft Drop                                              DONE
//Firm Drop                                            NO
Hard Drop                                              DONE
Delayed Auto Shift                                     DONE
Wall kicks                                             BUGGY, theoretically, "I" won't kick 2 over
Clockwise Rotation                                     DONE
//Hold piece                                           NO
Right Side Bias                                        DONE
Allow only 1 floor kick                                IMPLEMENT!!!
Allow I wall kicking always.                           IMPLEMENT!!!
Allow I floor kicking even when not touching ground    IMPLEMENT!!!
Adhere to SRS guidelines, some ARS guidelines
  http://tetris.wikia.com/wiki/SRS
  http://tetris.wikia.com/wiki/ARS

*/
