//Tetris
//Joseph Dykstra


/*              PREPROCESSOR              */
#include "+Button+-.nxc"
#include "+Highscore.nxc"
#include "+RotatedNumbers.nxc"
//Dimensions / Graphics
#define b       4
#define width   10
#define height  15 //change back to 25!
#define TX      35
#define SX      94 //change back to 94!
#define SY      61
//Timing
#define waitMove    100
#define waitRotate  100
#define waitDrop    100
//tetriminos
#define Itet 0
#define Jtet 1
#define Ltet 2
#define Otet 3
#define Stet 4
#define Ttet 5
#define Ztet 6
#define prob 7


/*            GLOBAL CONSTANTS            */
const int I[8]=
 {0,1,2,3,
  1,1,1,1};
const int J[8]=
 {0,1,2,0,
  1,1,1,0};
const int L[8]=
 {0,1,2,2
  1,1,1,0};
const int O[8]=
 {0,0,1,1,
  0,1,0,1};
const int S[8]=
 {2,1,1,0,
  0,0,1,1};
const int T[8]=
 {0,1,1,2,
  0,0,1,0};
const int Z[8]=
 {0,1,1,2,
  0,0,1,1};


/*            GLOBAL VARIABLES            */
string msg;
string disp;
string accesshigh;
float speedup;
int score;
int gametype;
int gamespeed;
int delaytime;
int prevC;
int prevE;
int prevL;
int prevR;
int currentPiece;
int comingPiece;
int tetX;
int tetY;
bool moveL;
bool moveR;
bool rotate;
bool drop;
bool prevQuadClear;


bool area[width][height+1];
int chnc[8];


/*               SUBROUTINES              */
void selectGame(bool fastmode)
  {
  prevQuadClear=false;
  prevC=0;
  prevE=0;
  score=0;
  currentPiece=-1;
  if (fastmode)
    {
    speedup=0.9;
    delaytime=400;
    accesshigh="TetrisFastGive.dat";
    chnc[Itet]=2;
    chnc[Jtet]=1;
    chnc[Ltet]=1;
    chnc[Otet]=2;
    chnc[Stet]=0;
    chnc[Ttet]=1;
    chnc[Ztet]=0;
    chnc[prob]=7;
    }
  else
    {
    accesshigh="Tetris";
    while (ButtonPressed(BTNRIGHT)==false)
      {
      gamespeed=senseButton(gamespeed,false,1,2,false);
      ClearScreen();
      TextOut(TX,LCD_LINE1,"TETRIS", 0);
      TextOut(2, LCD_LINE2,"Speed:", 0);
      TextOut(2, LCD_LINE3,"Slow",   0);
      TextOut(2, LCD_LINE4,"Medium", 0);
      TextOut(2, LCD_LINE5,"Fast",   0);
      TextOut(88,LCD_LINE8,"OK",     0);
      RectOut(0,40-(gamespeed*8),49,8,0);
      Wait(50);
      }
    TextOut(TX,LCD_LINE1,"TETRIS",  0);
    until (ButtonPressed(BTNRIGHT)==false) {}
    while (ButtonPressed(BTNRIGHT)==false)
      {
      gametype=senseButton(gametype,false,1,4,false);
      ClearScreen();
      TextOut(TX,LCD_LINE1,"TETRIS",   0);
      TextOut(2, LCD_LINE2,"Type:",    0);
      TextOut(2, LCD_LINE3,"Giveaway", 0);
      TextOut(2, LCD_LINE4,"Simple",   0);
      TextOut(2, LCD_LINE5,"Normal",   0);
      TextOut(2, LCD_LINE6,"Hard",     0);
      TextOut(2, LCD_LINE7,"Death",    0);
      TextOut(88,LCD_LINE8,"OK", 0);
      RectOut(0,40-(gametype*8),49,8,0);
      Wait(50);
      }
    TextOut(TX,LCD_LINE1,"TETRIS",  0);
    until (ButtonPressed(BTNRIGHT)==false) {}
    //
    if      (gamespeed==0)
      {
      accesshigh=StrCat(accesshigh,"Slow");
      speedup=0.975;
      delaytime=800;
      }
    else if (gamespeed==1)
      {
      accesshigh=StrCat(accesshigh,"Med");
      speedup=0.9375;
      delaytime=600;
      }
    else if (gamespeed==2)
      {
      accesshigh=StrCat(accesshigh,"Fast");
      speedup=0.9;
      delaytime=400;
      }

    if      (gametype==0)
      {
      accesshigh=StrCat(accesshigh,"Give.dat");
      chnc[Itet]=2;
      chnc[Jtet]=1;
      chnc[Ltet]=1;
      chnc[Otet]=2;
      chnc[Stet]=0;
      chnc[Ttet]=1;
      chnc[Ztet]=0;
      chnc[prob]=7;
      }
    else if (gametype==1)
      {
      accesshigh=StrCat(accesshigh,"Simp.dat");
      chnc[Itet]=3;
      chnc[Jtet]=1;
      chnc[Ltet]=1;
      chnc[Otet]=3;
      chnc[Stet]=1;
      chnc[Ttet]=2;
      chnc[Ztet]=1;
      chnc[prob]=12;
      }
    else if (gametype==2)
      {
      accesshigh=StrCat(accesshigh,"Norm.dat");
      chnc[Itet]=1;
      chnc[Jtet]=1;
      chnc[Ltet]=1;
      chnc[Otet]=1;
      chnc[Stet]=1;
      chnc[Ttet]=1;
      chnc[Ztet]=1;
      chnc[prob]=7;
      }
    else if (gametype==3)
      {
      accesshigh=StrCat(accesshigh,"Hard.dat");
      chnc[Itet]=2;
      chnc[Jtet]=3;
      chnc[Ltet]=3;
      chnc[Otet]=2;
      chnc[Stet]=4;
      chnc[Ttet]=3;
      chnc[Ztet]=4;
      chnc[prob]=21;
      }
    else if (gametype==4)
      {
      accesshigh=StrCat(accesshigh,"Death.dat");
      chnc[Itet]=1;
      chnc[Jtet]=3;
      chnc[Ltet]=3;
      chnc[Otet]=2;
      chnc[Stet]=4;
      chnc[Ttet]=2;
      chnc[Ztet]=4;
      chnc[prob]=19;
      }
    ClearScreen();
    }
  }


void getInput()
  {
  if (ButtonPressed(BTNLEFT))
    {
    if (prevL==0)
      {
      drop=true;
      }
    prevL++;
    if (prevL<waitDrop)
      {
      prevL=0;
      }
    }
  if (ButtonPressed(BTNRIGHT))
    {
    if (prevR==0)
      {
      rotate=true;
      }
    prevR++;
    if (prevR<waitRotate)
      {
      prevR=0;
      }
    }
  if (ButtonPressed(BTNCENTER))
    {
    if (prevC==0)
      {
      moveL=true;
      }
    prevC++;
    if (prevC<waitMove)
      {
      prevC=0;
      }
    }
  if (ButtonPressed(BTNEXIT))
    {
    if (prevE==0)
      {
      moveR=true;
      }
    prevE++;
    if (prevE<waitMove)
      {
      prevE=0;
      }
    }
  }
  
  
                             //\\
                           ////\\\\
                         //////\\\\\\
                     //////////\\\\\\\\\\
 //////////////////////////////\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
//////////////////////////////  \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
  

void pieceCreate()
  {
  comingPiece=currentPiece;
  int rndm;
  int pieceToCreate=0;
  rndm=Random(chnc[prob]);
  for (int i=0; (i<Ztet)&&(pieceToCreate==0); i++)
    {
    if (rndm<chnc[i])
      {
      pieceToCreate=i;
      }
    }
  currentPiece=pieceToCreate;
  }
  
  
bool clearFullRows()   //////////////////// - - FIX - - ////////////////////
  {
  int blocksInRow=0;
  int numOfFilledLines=0;
  int i,j,k;
  for (i=0; i<height; i++)
    {
    for (j=0; j<width; j++)         //add up blocks in row
      {
      blocksInRow+=(area[j][i]);    //switch i & j???
      }
    if (blocksInRow==width)         //if the row is full
      {
      for (k=i; k<height; k++)      //move higher rows down
        {
        for (j=0; j<width; j++)
          {
          area[j][k]=area[j][k+1];   //switch k & j???
          }
        }
      i--; //redo row if it gets destroyed
      numOfFilledLines++;
      }
    }
  //add to score
  if      (numOfFilledLines==1)    {score+=100; prevQuadClear=false; disp="Single!";}
  else if (numOfFilledLines==2)    {score+=200; prevQuadClear=false; disp="Double!";}
  else if (numOfFilledLines==3)    {score+=400; prevQuadClear=false; disp="Triple!";}
  else if (numOfFilledLines==4)
    {
    if (!prevQuadClear)   {score+=800;  prevQuadClear=true; disp="Tetris!";}
    else                  {score+=1200; prevQuadClear=true; disp="Single!";}
    }
  return (numOfFilledLines>0);

  }
  
  
void nextStep()
  {
  tetX--;
  }
  


void redraw()
  {
  int i;
  int j;
  for (i=0; i<height; i++)
    {
    for (j=0; j<width; j++)
      {
      //RectOut(i*b,j*b,b,b,( (area[j][i]*28) +4));
      if (area[j][i]) RectOut(i*b,j*b,b,b,32);
      }
    }
  RotatedNumbersOut(SX,SY,score);
  }


void debug(int mode)
  {
  if (mode==2) //ClearFullRows
    {
    bool playagain, alive, piecemoving;
    for (int i=0; i<height; i++)
      {
      for (int j=0; j<width; j++)
        {
        area[j][i]=(Random(5)!=1);
        }
      }
    prevQuadClear=false;
    prevC=0;
    prevE=0;
    score=Random(INT_MAX-10000)+10000;//score=0;
    currentPiece=-1;
    ClearScreen();
    redraw();
    Wait(5000);
    ClearScreen();
    PlayTone(2000,100);
    clearFullRows();
    redraw();
    Wait(5000);
    }
  }
  

task main()
  {
  int mode=2;
  if (mode==0||mode==1)
    {
    SetLongAbort(true);
    bool playagain, alive, piecemoving;
    for (int i=0; i<height; i++)
      {
      for (int j=0; j<width; j++)
        {
        area[j][i]=(Random(3)+1)%2;
        //area[j][i]=0;
        }
      }
    playagain=true;
    while (playagain)
      {
      selectGame(mode);
      alive=true;
      while (alive)
        {
        pieceCreate();
        piecemoving=true;
        while (piecemoving)
          {
          for (int i=0;i<delaytime/10;i++) //waiting
            {
            getInput();
            Wait(10);
            }
          nextStep();
          redraw();
          //debugging
          }
        //set piece into area
        clearFullRows();
        }
      //play again?
      }
    }
  else
    {
    debug(mode);
    }
  }
