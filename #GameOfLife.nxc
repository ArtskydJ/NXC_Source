//Game Of Life
//Joseph Dykstra
//01-15-2013


#include "+Menu.nxc"

#define TX      12
#define height  64  //64
#define width   13  //104
#define rndm  0
#define rset  1
#define mode  0


//bool area[width+2][height+2][2];
byte area[width][height+2][2];

/*
const byte gliderGun[5][9]=
 {{0x00000000,0x00000000,0x00000000,0x10000000,0x00000000}
  {0x00000000,0x00000000,0x00000010,0x10000000,0x00000000}
  {0x00000000,0x00001100,0x00001100,0x00000000,0x00110000}
  {0x00000000,0x00010001,0x00001100,0x00000000,0x00110000}
  {0x11000000,0x00100000,0x10001100,0x00000000,0x00000000}
  {0x11000000,0x00100010,0x11000010,0x10000000,0x00000000}
  {0x00000000,0x00100000,0x10000000,0x10000000,0x00000000}
  {0x00000000,0x00010001,0x00000000,0x00000000,0x00000000}
  {0x00000000,0x00001100,0x00000000,0x00000000,0x00000000}};

const byte glider[3]=
 {0x00010000,
  0x00001000,
  0x00111000};
  
const byte lightWeightSpaceShip[4]=
 {0x00010010,
  0x00000001,
  0x00010001,
  0x00001111};*/
  
  
void make(int INchoice,bool INwhicharea)
  {
  if (INchoice==0)
    {
    for (int i=0; i<5; i++)
      {
      for (int j=0; j<9; j++)
        {
        //area[i+1][j+1][INwhicharea]=gliderGun[i][j];
        }
      }
    }
  }


void initArea(bool rsetRndm, bool INwhicharea)
  {
  for (int i=0; i<height+2; i++)
    {
    for (int j=0; j<width; j++)
      {
      if (rsetRndm) area[j][i][INwhicharea]=0;
      else          area[j][i][INwhicharea]=Random(UCHAR_MAX);
      }
    }
  }


void draw(bool INcurrarea, int INblksz)
  {
  for (int i=1; i<height+1; i++)
    {
    for (int j=1; j<width-1; j++)
      {
      //RectOut(j-1,i-1,INblksz,INblksz,(-area[j][i][INcurrarea])*4+36);
      TextOut(0,0,"lolz",0);
      }
    }
  }


void stepForward(bool INcurrarea)
  {
  int neighbors;
  for (int i=1; i<height+1; i++)
    {
    for (int j=1; j<width-1; j++)
      {
      neighbors=0;
      for (int k=-1; k<2; k++)
        {
        PlayTone(3000,100);Wait(125);
        for (int l=-1; l<2; l++)
          {
          if (k==0&&l==0) l++;
          neighbors+=(area[j+l][i+k][INcurrarea]);
          }
        }
      if (area[j][i]) //LIVE CELL
        {
        if (neighbors<2)  area[j][i][!INcurrarea]=false; //Under population
        if (neighbors>3)  area[j][i][!INcurrarea]=false; //Over crowding
        }
      else            //DEAD CELL
        {
        if (neighbors==3) area[j][i][!INcurrarea]=true;  //Reproduction
        }
      }
    }
  }

/*
int startupMenu(int INmenu)
  {
  string output[8]={"","","","","","","",""};
  int choice;
  output[0]="GAME OF LIFE";
  if (INmenu==0)
    {
    output[1]="Choose:";
    output[2]="Random";
    output[3]="GlidrGun";
    output[4]="Glider";
    output[5]="LtWtSpSh";
    output[6]="Misc";
    choice=menu(5, output, TX);
    }
  else if (INmenu==1)
    {
    output[1]="Speed:";
    output[2]="XtraFast";
    output[3]="Fast";
    output[4]="Medium";
    output[5]="Slow";
    choice=menu(4, output, TX);
    }
  else if (INmenu==2)
    {
    output[1]="Size:";
    output[2]="Small";
    output[3]="Medium";
    output[4]="Large";
    choice=menu(3, output, TX);
    }
  ClearScreen();
  return choice;
  }
*/

task main()
  {
  int choice[3];
  int waitTime;
  bool currArea=0;
  if (mode) {for (int i=0; i<3; i++) {choice[i]=startupMenu(i);}}
  else
    {
    choice[0]=
    choice[1]=
    choice[2]=
    }
  TextOut(32,20,"Loading",0);
  if (choice[0]==0)                  //If chose random
    {
    unsigned int ctick=CurrentTick();//Get current tick
    srand(ctick);                    //Seed randomizer
    //initArea(rndm,currArea);         //Randomize
    }
  else                               //If chose diff preset
    {
    //initArea(rset,currArea);         //Reset area
    make(choice[0],currArea);        //Create preset
    }
  waitTime=choice[1]*100;
  const int blksz=(choice[2]*2+1);
  ClearScreen();
  SetLongAbort(false);
  Wait(1000);
  for (int gens=0; true; gens++)
    {
    draw(currArea,blksz);
    PlayTone(1000,250);Wait(250);
    currArea=!currArea;
    stepForward(currArea);
    PlayTone(1500,250);Wait(250);
    //Wait(waitTime);
    }
  }

  
/*
byte toByte(bool INbools)
{
  byte OUTbyte = \0;
  for(int i = 0; i < 8; ++i) OUTbyte|=((unsigned char) INbools[i]) << i;
  return OUTbyte;
}
*/
  
  
/*
neighbors+=(area[j-1][i-1]);
neighbors+=(area[j-1][i  ]);
neighbors+=(area[j-1][i+1]);
neighbors+=(area[j  ][i-1]);
neighbors+=(area[j  ][i+1]);
neighbors+=(area[j+1][i-1]);
neighbors+=(area[j+1][i  ]);
neighbors+=(area[j+1][i+1]);
*/


/*
const bool gliderGun[36][9]={
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0}
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0}
{0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1}
{0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1}
{1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
{1,1,0,0,0,0,0,0,0,0,1,0,0,0,1,0,1,1,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0}
{0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0}
{0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
{0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}};
*/


/*

I don't think conways game of life will work on the NXT.
 It throws OUT OF MEMORY errors (-5) and crashes a few steps into the loop.
 But hypothetically, it shouldn't ever need more memory than what it starts with.
 If I'm very careful...

But I foresee an issue with checking the individual bits in the bytes,
 instead of reading bools (which are declared as the same size as a byte).
 The issue is:
  If the currently checked bit is either the   first or last   bit,
  then the program will have to check the       last or first  bit
                            in either the   previous or next   byte.
  This will make the code much more confusing,
  but is probably what I will need to do.

*/
